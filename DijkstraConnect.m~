
[l, w, h] = size(ROI);
weight = 1-img_prop(max(vertex(1)-MAX_DIST, 1):min(vertex(1)+MAX_DIST, size(L,1)), ...
    max(vertex(2)-MAX_DIST, 1):min(vertex(2)+MAX_DIST, size(L, 2)), ...
    max(vertex(3)-MAX_DIST, 1):min(vertex(3)+MAX_DIST, size(L, 3)))/65536;
weight = weight(:)'; % flatten
s = [];
t = [];
weights = [];
%seq = (0:h-1).*(l*w);
for j = 1:h-1
    s = [s, (1:(l*w))+l*w*(j-1)];
    t = [t, (1:(l*w))+l*w*j];
    weights = [weights, weight((1:(l*w))+l*w*j)];
end
s0 = (repmat(1:l,h,1)+((0:h-1)*(l*w))')';
for j = 1:w-1
    s = [s, s0(:)'+l*(j-1)];
    t = [t, s0(:)'+l*j];
    weights = [weights, weight(s0(:)'+l*j)];
end
s0 = (repmat((0:w-1)*l,h,1)+((0:h-1)*(w*l))'+1)';
for j = 1:l-1
    s = [s, s0(:)'+(j-1)];
    t = [t, s0(:)'+j];
    weights = [weights, weight(s0(:)'+j)];
end
% Dijkstra
G = graph(s, t, weights);
center_ = l*w*(center(3)-1) + l*(center(2)-1) + center(1);
target_ = l*w*(target(3)-1) + l*(target(2)-1) + target(1);
[path, cost] = shortestpath(G, center_, target_);
% retrieve path as 3-D point series
path = path';
row = mod(path, l);
row(~row) = l; % mod(_,l) result could be 0, but should be l
col = ceil(mod(path, l*w)/l);
col(~col) = w;
height = ceil(path/(l*w));
%     [row col height]
path = [row col height];